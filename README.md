# Dynamic-Programming
这个仓库会发布动态规划(dp)的经典题目：
## 目录
* [Problem 1 爬楼梯问题（一维DP）](#problem1)
* [Problem 2 路径问题（二维DP）](#problem2)
* [Problem 3 找硬币问题（一维DP）](#problem3)
* [Problem 4 0-1背包问题（二维DP）](#problem4)
* [Problem 5 最大子链（线性）问题1](#problem5)
* [Problem 6 最大子链（环形）问题](#problem6)
* [Problem 7 最大子链（子链长度给定）问题](#problem7)
## Problem 1 爬楼梯问题（一维DP）
<a name="problem1"></a>
一只青蛙一次可以跳上一级或两级台阶，求该青蛙跳上n级台阶共有多少种跳法。

**输入格式**：输入n的值。

**输出格式**：打印跳法总数。

### 动态规划状态转移方程：记dp[i]为跳到第i级台阶时的跳法总数，则

```
dp[i]=dp[i-1]+dp[i-2]
#（第i阶跳法总数等于在第i-1阶时跳一级或者在第i-2阶时跳两级，同时这也是斐波那契数列）
```
## Problem 2 路径问题（二维DP）
<a name="problem2"></a>
一个机器人位于一个 m x n 网格的左上角（起始点在下图中标记为 “Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。问总共有多少条不同的路径？
![](problem2.jpg)

**输入格式**：输入m，n的值。

**输出格式**：输出路径总数。

### 动态规划状态转移方程：记dp[i][j]为从起始点(start)走到坐标系中(i,j)该点处共有几条路径，则

```
dp[i][j]=dp[i-1][j]+dp[i][j-1]
#（相当于在走到点(i-1,j)的基础上向右走一格，或者是在点(i,j-1)的基础上向下走一格）
```

## Problem 3 找硬币问题（一维DP）：
<a name="problem3"></a>
店员给顾客找零钱，已知共需要找出n元钱，并且有k种硬币面值，问最少需要几枚硬币。

**输入格式**：第一行输入目标总零钱数n和硬币种类数k；第二行及以下k行输入每种硬币对应的面值。

**输出格式**：打印所需最少硬币数。

### 动态规划状态转移方程：记dp[i]为考虑共需找零i元时的最少硬币数，则

```
dp[i]=min(dp[i],dp[i-coin]+1)   (i>coin)
     =1                          (i==coin)
     =dp[i]                      (i<coin)
#（其中i需从1到n遍历一遍，为外循环；coin硬币数组也需要遍历一遍，为各个i中的内循环。）
```
## Problem 4 0-1背包问题（二维DP）：
<a name="problem4"></a>
有 n 件物品，每件物品有重量 w [i] 和价值 v [i]，背包的最大容量为 C。每件物品只能选择放入或不放入背包，求能放入背包的最大总价值。

**输入格式**：第一行输入背包最大容量c和物品件数n；第二行及以下n行输入每件物品的重量和价值。

**输出格式**：打印最大总价值

### 解法一：暴力穷举（运用位运算枚举）

### 解法二：动态规划（状态转移方程：记dp[i][j]为考虑前i件物品且背包最多装j单位容量情况下的最大总价值，则

```
dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])  (j>w[i])
        =dp[i-1][j]                            (j<=w[i])
```
## Problem 5 最大子链（线性）问题：
<a name="problem5"></a>
在线性(首尾不相连）的数组或序列中寻找最大子链（通常也叫最大子数组、最大子段等），例如给定一个整数数组 nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]，目标是找出其中连续元素之和最大的子数组。
**输入格式**：输入目标数组nums。

**输出格式**：输出最大子链的元素之和。

### 动态规划状态转移方程：记以当前元素nums[i]结尾的最大子链为current_MAX[i],遍历至nums[i]时（即考虑前i个元素时）的全局最大子链为global-MAX[i]，则：

```
current_MAX[i]=max(current_MAX[i-1]+nums[i],nums[i]);
global_MAX[i]=max(global_MAX[i-1],current_MAX[i]);
#(current_MAX的作用是记录以当前第i个元素结尾的最大子链，这一最大子链有且只有两种情况：要么是以第i-1个元素结尾的最大子链加上第i个元素，要么就只是第i个元素自己构成最大子链（当以第i-1个元素结尾的最大子链为负数时）

#（global_MAX的作用是比较以第i-1个元素结尾的最大子链与第i个元素结尾的最大子链，从而得到全局最优解）

